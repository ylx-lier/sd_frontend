# Stable Diffusion + ControlNet 图像生成应用修改记录

## 🔄 2025-06-27 更新: img2img技术原理完善

### 问题描述
用户反馈img2img功能在API模式下提示"没有对应的API"，并提到ComfyUI中img2img通过VAE编码器实现。

### 技术分析
通过深入分析，确认了img2img的技术原理和API限制：

#### img2img完整流程
1. **VAE编码器** → 将输入图像编码到潜在空间
2. **噪声调制** → 根据strength参数添加噪声
3. **UNet采样** → 在潜在空间进行去噪，结合文本提示
4. **VAE解码器** → 将潜在表示解码回图像空间

#### API模式限制原因
- 公共API通常只提供简化的text-to-image接口
- img2img需要完整的模型管道（VAE编码器、UNet、VAE解码器）
- 复杂的潜在空间操作不适合HTTP API封装
- 计算资源和数据传输限制

### 具体改进

#### 1. 更新img2img API函数
```python
def generate_img2img_api(prompt, negative_prompt, input_image, strength):
    """Generate img2img image using API - 技术说明版本"""
    
    # 技术原理说明：img2img需要完整的VAE编码/解码流程
    # 直接返回技术说明，不进行实际API调用
    return None, "技术原理说明和替代方案..."
```

#### 2. 添加技术说明UI
- 在img2img标签页添加技术原理说明
- 说明本地模式 vs API模式的区别
- 提供ComfyUI对比分析

#### 3. 优化用户指导
- 详细解释为什么API模式不适合img2img
- 推荐使用本地模式或ControlNet替代
- 提供参数调优建议

#### 4. 创建技术文档
- `img2img技术原理说明.md`: 详细技术原理
- `img2img_API解决方案.md`: 用户解决方案指南

#### 5. 简化API测试功能
- 将img2img API测试改为技术说明展示
- 不进行实际API调用避免无意义的错误

### 用户体验改进
1. **清晰的技术说明**: 让用户理解为什么API模式限制img2img
2. **替代方案指导**: 推荐本地模式或ControlNet模式
3. **技术对比**: 与ComfyUI的对比分析
4. **参数优化建议**: 针对不同需求的参数设置

### 技术结论
img2img本质上是一个需要完整模型管道的复杂流程，更适合本地计算而非API调用。这解释了为什么ComfyUI通过独立的VAE编码器节点能够实现高质量的img2img功能。

---

## 项目概述
构建和优化一个本地/云端双模式的 Stable Diffusion + ControlNet 图像生成 Gradio 应用，支持多模型选择、ControlNet多控制类型、prompt辅助选择器，并兼容 Hugging Face API 推理模式以节省本地存储空间。

## 主要问题
- API模式下的编码报错：'latin-1' codec can't encode character
- 存储空间优化需求
- prompt辅助功能完善需求

## 详细修改记录

### 1. 编码问题修复

#### 问题分析
'latin-1' 编码错误不是由注释引起的，而是由以下原因：
1. API返回的响应中包含非ASCII字符
2. 错误消息或异常信息中包含非ASCII字符
3. 请求payload中包含非ASCII字符

#### 具体修改

##### 1.1 修复 `query_hf_api` 函数
```python
# 修改前
def query_hf_api(endpoint, payload, api_token=None):
    # ... 原始代码包含中文错误消息
    elif response.status_code == 503:
        raise Exception("模型正在加载中，请稍后重试")
    # ... 其他中文错误消息

# 修改后
def query_hf_api(endpoint, payload, api_token=None):
    """Call Hugging Face API"""
    headers = {"Content-Type": "application/json"}
    if api_token:
        headers["Authorization"] = f"Bearer {api_token}"
    
    try:
        response = requests.post(endpoint, headers=headers, json=payload, timeout=60)
        if response.status_code == 200:
            return response.content
        elif response.status_code == 503:
            raise Exception("Model is loading, please try again later")
        elif response.status_code == 429:
            raise Exception("API rate limit exceeded, please try again later")
        elif response.status_code == 401:
            raise Exception("Invalid or missing API token")
        elif response.status_code == 404:
            raise Exception("Model endpoint not found")
        else:
            # Ensure error message is ASCII safe
            error_text = "Unknown API error"
            try:
                if response.text:
                    # Try to get ASCII-safe error message
                    error_text = response.text.encode('ascii', 'ignore').decode('ascii')
                    if not error_text.strip():
                        error_text = "API error with non-ASCII response"
            except:
                error_text = "API response encoding error"
            raise Exception(f"API call failed: {response.status_code}, {error_text}")
    except requests.exceptions.Timeout:
        raise Exception("API call timeout, please check network connection")
    except requests.exceptions.ConnectionError:
        raise Exception("Network connection error, please check network settings")
    except Exception as e:
        # Ensure all error messages are ASCII safe
        error_msg = str(e)
        try:
            error_msg.encode('ascii')
        except UnicodeEncodeError:
            error_msg = "API call error with encoding issues"
        raise Exception(error_msg)
```

##### 1.2 修复 `generate_image_api` 函数
```python
def generate_image_api(prompt, negative_prompt="", model_id="runwayml/stable-diffusion-v1-5"):
    """Generate image using API"""
    endpoint = API_ENDPOINTS.get(model_id)
    if not endpoint:
        raise Exception(f"Model {model_id} does not support API mode")
    
    # Ensure prompt and negative_prompt are ASCII safe
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": safe_prompt,
        "parameters": {
            "negative_prompt": safe_negative_prompt,
            "num_inference_steps": 20,
            "guidance_scale": 7.5,
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        return image, "API image generation successful!"
    except Exception as e:
        return None, f"API generation failed: {str(e)}"
```

##### 1.3 修复 `generate_controlnet_image_api` 函数
```python
def generate_controlnet_image_api(prompt, negative_prompt, control_image, control_type):
    """Generate ControlNet image using API"""
    endpoint = CONTROLNET_API_ENDPOINTS.get(control_type)
    if not endpoint:
        raise Exception(f"ControlNet type {control_type} does not support API mode")
    
    # Convert control image to base64
    import base64
    import io
    
    buffered = io.BytesIO()
    control_image.save(buffered, format="PNG")
    control_image_b64 = base64.b64encode(buffered.getvalue()).decode()
    
    # Ensure prompt and negative_prompt are safe
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": {
            "prompt": safe_prompt,
            "image": control_image_b64,
            "negative_prompt": safe_negative_prompt
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        control_type_name = CONTROLNET_TYPES[control_type]['name']
        return image, f"API mode {control_type_name} image generation successful!"
    except Exception as e:
        return None, f"ControlNet API generation failed: {str(e)}"
```

##### 1.4 修复 `generate_img2img_api` 函数
```python
def generate_img2img_api(prompt, negative_prompt, input_image, strength):
    """Generate img2img image using API"""
    endpoint = API_ENDPOINTS.get("runwayml/stable-diffusion-v1-5")
    if not endpoint:
        raise Exception("img2img API mode not supported")
    
    # Convert input image to base64
    import base64
    import io
    
    buffered = io.BytesIO()
    input_image.save(buffered, format="PNG")
    input_image_b64 = base64.b64encode(buffered.getvalue()).decode()
    
    # Ensure prompt and negative_prompt are safe
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": {
            "prompt": safe_prompt,
            "image": input_image_b64,
            "negative_prompt": safe_negative_prompt,
            "strength": strength
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        return image, "API mode img2img image generation successful!"
    except Exception as e:
        return None, f"img2img API not supported, recommend using local mode or text-to-image function: {str(e)}"
```

### 2. 负面词条辅助功能添加

#### 2.1 添加负面词条分类
```python
# 负面提示词辅助词条
NEGATIVE_PROMPT_CATEGORIES = {
    "画质问题": [
        "blurry", "low quality", "bad quality", "worst quality", "poor quality",
        "pixelated", "jpeg artifacts", "compression artifacts", "distorted",
        "low resolution", "grainy", "noisy", "oversaturated", "undersaturated"
    ],
    "解剖错误": [
        "bad anatomy", "bad hands", "bad fingers", "extra fingers", "missing fingers",
        "extra limbs", "missing limbs", "deformed", "mutated", "disfigured",
        "malformed", "extra arms", "extra legs", "fused fingers", "too many fingers"
    ],
    "面部问题": [
        "bad face", "ugly face", "distorted face", "asymmetrical face",
        "bad eyes", "cross-eyed", "extra eyes", "missing eyes", "bad mouth",
        "bad teeth", "crooked teeth", "bad nose", "asymmetrical features"
    ],
    "艺术风格": [
        "cartoon", "anime", "manga", "3d render", "painting", "sketch",
        "watercolor", "oil painting", "digital art", "illustration",
        "abstract", "surreal", "unrealistic", "stylized"
    ],
    "技术问题": [
        "watermark", "signature", "text", "logo", "copyright", "username",
        "frame", "border", "cropped", "cut off", "out of frame",
        "duplicate", "error", "glitch", "artifact"
    ],
    "光照问题": [
        "bad lighting", "harsh lighting", "overexposed", "underexposed",
        "too dark", "too bright", "uneven lighting", "poor contrast",
        "washed out", "flat lighting", "artificial lighting"
    ],
    "构图问题": [
        "bad composition", "off-center", "tilted", "crooked", "unbalanced",
        "cluttered", "messy", "chaotic", "poor framing", "bad angle",
        "awkward pose", "stiff pose", "unnatural pose"
    ]
}
```

#### 2.2 修改界面添加负面词条选择器
在 `create_interface()` 函数中添加：

```python
# 负面词条
gr.Markdown("#### 🚫 负面提示词 (Negative Prompt)")
with gr.Row():
    with gr.Column():
        neg_quality_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["画质问题"],
            label="🚫 画质问题",
            info="避免画质相关问题"
        )
        neg_anatomy_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["解剖错误"],
            label="🚫 解剖错误",
            info="避免身体结构错误"
        )
    with gr.Column():
        neg_face_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["面部问题"],
            label="🚫 面部问题",
            info="避免面部相关问题"
        )
        neg_style_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["艺术风格"],
            label="🚫 避免风格",
            info="排除不想要的艺术风格"
        )
    with gr.Column():
        neg_tech_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["技术问题"],
            label="🚫 技术问题",
            info="避免水印、裁剪等技术问题"
        )
        neg_lighting_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["光照问题"],
            label="🚫 光照问题",
            info="避免光照相关问题"
        )
    with gr.Column():
        neg_composition_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["构图问题"],
            label="🚫 构图问题",
            info="避免构图相关问题"
        )
```

#### 2.3 修改每个标签页的按钮布局
将原来的单一"应用标签"按钮替换为两个按钮：

**文生图模式：**
```python
with gr.Row():
    prompt1 = gr.Textbox(
        label="提示词 (Prompt)",
        placeholder="描述你想要的图像，例如：a beautiful landscape with mountains and lakes, highly detailed, 4k",
        lines=3,
        scale=4
    )
    with gr.Column(scale=1):
        apply_positive_to_prompt1 = gr.Button("➕ 正面词条", variant="secondary", size="sm")
        apply_negative_to_prompt1 = gr.Button("➖ 负面词条", variant="secondary", size="sm")
```

**传统图生图模式：**
```python
with gr.Row():
    prompt_img2img = gr.Textbox(
        label="提示词 (Prompt)",
        placeholder="描述想要的风格变化，例如：oil painting style, vibrant colors",
        lines=3,
        scale=4
    )
    with gr.Column(scale=1):
        apply_positive_to_img2img = gr.Button("➕ 正面词条", variant="secondary", size="sm")
        apply_negative_to_img2img = gr.Button("➖ 负面词条", variant="secondary", size="sm")
```

**ControlNet模式：**
```python
with gr.Row():
    prompt2 = gr.Textbox(
        label="提示词 (Prompt)",
        placeholder="基于上传图像的结构，描述想要的风格，例如：oil painting style, sunset colors",
        lines=3,
        scale=4
    )
    with gr.Column(scale=1):
        apply_positive_to_prompt2 = gr.Button("➕ 正面词条", variant="secondary", size="sm")
        apply_negative_to_prompt2 = gr.Button("➖ 负面词条", variant="secondary", size="sm")
```

#### 2.4 更新事件绑定逻辑
修改了标签应用逻辑，从累加改为替换：

```python
# Prompt 辅助器事件
def get_selected_positive_tags(*tag_groups):
    """获取所有选中的正面标签"""
    selected_tags = []
    for tags in tag_groups:
        if tags:
            selected_tags.extend(tags)
    return ", ".join(selected_tags) if selected_tags else ""

def get_selected_negative_tags(*tag_groups):
    """获取所有选中的负面标签"""
    selected_tags = []
    for tags in tag_groups:
        if tags:
            selected_tags.extend(tags)
    return ", ".join(selected_tags) if selected_tags else ""

def clear_all_tags():
    return [[] for _ in range(14)]  # 7个正面tag组 + 7个负面tag组

# 正面词条应用到各个prompt框的事件
apply_positive_to_prompt1.click(
    get_selected_positive_tags,
    inputs=[quality_tags, style_tags, lighting_tags, composition_tags, mood_tags, scene_tags, color_tags],
    outputs=[prompt1]
)

# 负面词条应用到各个negative prompt框的事件
apply_negative_to_prompt1.click(
    get_selected_negative_tags,
    inputs=[neg_quality_tags, neg_anatomy_tags, neg_face_tags, neg_style_tags, neg_tech_tags, neg_lighting_tags, neg_composition_tags],
    outputs=[negative_prompt1]
)

# ... 其他类似的事件绑定
```

### 3. 界面优化

#### 3.1 更新帮助文档
在界面说明中添加了关于负面词条的使用说明：

```markdown
### 🎯 **Prompt 辅助器使用说明：**
- **✨ 正面词条**：描述你想要的效果、风格、质量等
- **🚫 负面词条**：描述你不想要的问题、风格、瑕疵等
- **📝 应用方式**：点击 "➕正面词条" 或 "➖负面词条" 按钮直接替换当前内容
- **💡 使用技巧**：先选择词条，再点击应用到对应的提示词框中
```

#### 3.2 清理重复代码
发现并清理了代码中的重复函数定义，确保代码结构清晰。

### 4. 文件结构

最终的主要文件：
- `app.py` - 主应用文件
- `requirements.txt` - 依赖文件
- `README.md` - 项目说明
- `修改记录.md` - 本修改记录文件

### 5. 功能验证

应用成功启动并运行在 http://127.0.0.1:7860，包含以下功能：

1. ✅ API模式和本地模式切换
2. ✅ 多模型选择支持
3. ✅ 三种生成模式（文生图、传统图生图、ControlNet）
4. ✅ 正面和负面词条辅助器
5. ✅ 词条替换而非累加的逻辑
6. ✅ ASCII安全的API错误处理
7. ✅ UTF-8编码安全的prompt处理

### 6. 待解决问题

1. API模式下的进一步测试，确保编码问题完全解决
2. 可能需要根据实际使用情况调整API payload格式
3. ControlNet和img2img的API模式支持可能需要进一步优化

### 7. 技术要点

#### 编码安全处理策略：
1. 所有API相关的错误消息使用英文
2. 所有传递给API的prompt和negative_prompt进行UTF-8编码过滤
3. API响应的错误信息进行ASCII安全处理
4. 异常捕获时确保错误消息可以安全编码

#### 界面设计改进：
1. 分离正面和负面词条选择
2. 每个生成模式都有独立的词条应用按钮
3. 词条应用采用替换而非累加逻辑
4. 保持界面的一致性和易用性

---

## 修改时间线

1. **编码问题诊断** - 识别到问题不在注释而在API调用过程
2. **API函数重构** - 重写所有API相关函数，确保编码安全
3. **负面词条功能添加** - 添加7个分类的负面词条
4. **界面布局调整** - 为每个生成模式添加独立的词条应用按钮
5. **事件绑定更新** - 修改词条应用逻辑为替换而非累加
6. **代码清理** - 移除重复代码，优化结构
7. **功能验证** - 启动应用确认所有功能正常工作
8. **ControlNet API 修复** - 解决"Model endpoint not found"错误，优化错误提示

### 8. ControlNet API 问题修复 (2025-06-26)

#### 问题现象
用户报告"ControlNet API generation failed: Model endpoint not found"错误

#### 问题排查
1. **端点测试**：使用 `test_controlnet_api.py` 和 `test_controlnet_format.py` 测试发现：
   - ControlNet API 端点实际存在且可访问
   - API 格式正确（401错误表示需要有效token，而不是404）
   - 问题可能在于错误处理逻辑或API token验证

2. **根本原因**：
   - API token检查逻辑不够严格
   - 错误提示不够详细，用户难以判断真正原因
   - payload格式可能需要进一步优化

#### 具体修复

##### 8.1 改进 ControlNet API 函数
```python
def generate_controlnet_image_api(prompt, negative_prompt, control_image, control_type):
    """Generate ControlNet image using API - 修复版本"""
    # 更严格的API Token检查
    if not HF_API_TOKEN or not HF_API_TOKEN.strip():
        raise Exception("ControlNet API requires a valid Hugging Face API Token. Please set your token in the API settings.")
    
    # 简化并验证过的payload格式
    payload = {
        "inputs": safe_prompt,
        "parameters": {
            "image": control_image_b64,
            "negative_prompt": safe_negative_prompt,
            "num_inference_steps": 20,
            "guidance_scale": 7.5
        }
    }
    
    # 更详细的错误处理和用户友好的提示
    try:
        # ... API调用逻辑
    except Exception as e:
        error_msg = str(e)
        if "Model endpoint not found" in error_msg or "404" in error_msg:
            return None, f"❌ ControlNet模型 {control_type} 端点不可用。建议：1) 检查网络连接 2) 尝试其他控制类型 3) 使用本地模式"
        elif "401" in error_msg or "Invalid" in error_msg or "credentials" in error_msg.lower():
            return None, f"❌ API Token无效或未设置。请在API设置中输入有效的 Hugging Face Token"
        elif "503" in error_msg or "loading" in error_msg.lower():
            return None, f"⏳ ControlNet模型正在加载，请稍等1-2分钟后重试"
        elif "timeout" in error_msg.lower():
            return None, f"⏰ 连接超时，请检查网络连接或启用代理设置"
        else:
            return None, f"❌ ControlNet API调用失败: {error_msg}"
```

##### 8.2 添加 ControlNet API 连接测试功能
```python
def test_controlnet_api_connection(control_type, api_token):
    """测试ControlNet API连接"""
    # 独立的ControlNet API测试函数
    # 允许用户在生成前测试API连接状态
    # 提供详细的状态反馈
```

##### 8.3 界面增强
- 在API设置区域添加"ControlNet API测试"功能
- 提供实时的连接状态反馈
- 用户可以选择不同的ControlNet类型进行测试

#### 修复效果
1. **更准确的错误诊断**：区分不同类型的API错误并提供针对性建议
2. **用户友好的提示**：详细说明问题原因和解决方案
3. **预防性测试**：用户可以在生成前测试API连接
4. **更强的容错性**：处理各种网络和API状态异常

#### 使用建议
1. **首次使用**：在API设置中输入有效的Hugging Face Token
2. **连接测试**：使用"测试ControlNet API"功能验证连接
3. **网络问题**：如遇超时，启用代理设置
4. **模型加载**：如提示模型正在加载，等待1-2分钟后重试

## 最终状态

应用现在支持完整的双模式运行（API/本地），具备丰富的prompt辅助功能，解决了API模式下的编码问题，并大幅改进了ControlNet API的稳定性和用户体验。用户可以通过界面轻松选择正面和负面词条，一键应用到对应的提示词框中，并且能够实时测试API连接状态，确保生成过程的顺利进行。
