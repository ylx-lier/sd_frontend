# Stable Diffusion + ControlNet å›¾åƒç”Ÿæˆåº”ç”¨ä¿®æ”¹è®°å½•

## é¡¹ç›®æ¦‚è¿°
æ„å»ºå’Œä¼˜åŒ–ä¸€ä¸ªæœ¬åœ°/äº‘ç«¯åŒæ¨¡å¼çš„ Stable Diffusion + ControlNet å›¾åƒç”Ÿæˆ Gradio åº”ç”¨ï¼Œæ”¯æŒå¤šæ¨¡å‹é€‰æ‹©ã€ControlNetå¤šæ§åˆ¶ç±»å‹ã€promptè¾…åŠ©é€‰æ‹©å™¨ï¼Œå¹¶å…¼å®¹ Hugging Face API æ¨ç†æ¨¡å¼ä»¥èŠ‚çœæœ¬åœ°å­˜å‚¨ç©ºé—´ã€‚

## ä¸»è¦é—®é¢˜
- APIæ¨¡å¼ä¸‹çš„ç¼–ç æŠ¥é”™ï¼š'latin-1' codec can't encode character
- å­˜å‚¨ç©ºé—´ä¼˜åŒ–éœ€æ±‚
- promptè¾…åŠ©åŠŸèƒ½å®Œå–„éœ€æ±‚

## è¯¦ç»†ä¿®æ”¹è®°å½•

### 1. ç¼–ç é—®é¢˜ä¿®å¤

#### é—®é¢˜åˆ†æ
'latin-1' ç¼–ç é”™è¯¯ä¸æ˜¯ç”±æ³¨é‡Šå¼•èµ·çš„ï¼Œè€Œæ˜¯ç”±ä»¥ä¸‹åŸå› ï¼š
1. APIè¿”å›çš„å“åº”ä¸­åŒ…å«éASCIIå­—ç¬¦
2. é”™è¯¯æ¶ˆæ¯æˆ–å¼‚å¸¸ä¿¡æ¯ä¸­åŒ…å«éASCIIå­—ç¬¦
3. è¯·æ±‚payloadä¸­åŒ…å«éASCIIå­—ç¬¦

#### å…·ä½“ä¿®æ”¹

##### 1.1 ä¿®å¤ `query_hf_api` å‡½æ•°
```python
# ä¿®æ”¹å‰
def query_hf_api(endpoint, payload, api_token=None):
    # ... åŸå§‹ä»£ç åŒ…å«ä¸­æ–‡é”™è¯¯æ¶ˆæ¯
    elif response.status_code == 503:
        raise Exception("æ¨¡å‹æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨åé‡è¯•")
    # ... å…¶ä»–ä¸­æ–‡é”™è¯¯æ¶ˆæ¯

# ä¿®æ”¹å
def query_hf_api(endpoint, payload, api_token=None):
    """Call Hugging Face API"""
    headers = {"Content-Type": "application/json"}
    if api_token:
        headers["Authorization"] = f"Bearer {api_token}"
    
    try:
        response = requests.post(endpoint, headers=headers, json=payload, timeout=60)
        if response.status_code == 200:
            return response.content
        elif response.status_code == 503:
            raise Exception("Model is loading, please try again later")
        elif response.status_code == 429:
            raise Exception("API rate limit exceeded, please try again later")
        elif response.status_code == 401:
            raise Exception("Invalid or missing API token")
        elif response.status_code == 404:
            raise Exception("Model endpoint not found")
        else:
            # Ensure error message is ASCII safe
            error_text = "Unknown API error"
            try:
                if response.text:
                    # Try to get ASCII-safe error message
                    error_text = response.text.encode('ascii', 'ignore').decode('ascii')
                    if not error_text.strip():
                        error_text = "API error with non-ASCII response"
            except:
                error_text = "API response encoding error"
            raise Exception(f"API call failed: {response.status_code}, {error_text}")
    except requests.exceptions.Timeout:
        raise Exception("API call timeout, please check network connection")
    except requests.exceptions.ConnectionError:
        raise Exception("Network connection error, please check network settings")
    except Exception as e:
        # Ensure all error messages are ASCII safe
        error_msg = str(e)
        try:
            error_msg.encode('ascii')
        except UnicodeEncodeError:
            error_msg = "API call error with encoding issues"
        raise Exception(error_msg)
```

##### 1.2 ä¿®å¤ `generate_image_api` å‡½æ•°
```python
def generate_image_api(prompt, negative_prompt="", model_id="runwayml/stable-diffusion-v1-5"):
    """Generate image using API"""
    endpoint = API_ENDPOINTS.get(model_id)
    if not endpoint:
        raise Exception(f"Model {model_id} does not support API mode")
    
    # Ensure prompt and negative_prompt are ASCII safe
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": safe_prompt,
        "parameters": {
            "negative_prompt": safe_negative_prompt,
            "num_inference_steps": 20,
            "guidance_scale": 7.5,
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        return image, "API image generation successful!"
    except Exception as e:
        return None, f"API generation failed: {str(e)}"
```

##### 1.3 ä¿®å¤ `generate_controlnet_image_api` å‡½æ•°
```python
def generate_controlnet_image_api(prompt, negative_prompt, control_image, control_type):
    """Generate ControlNet image using API"""
    endpoint = CONTROLNET_API_ENDPOINTS.get(control_type)
    if not endpoint:
        raise Exception(f"ControlNet type {control_type} does not support API mode")
    
    # Convert control image to base64
    import base64
    import io
    
    buffered = io.BytesIO()
    control_image.save(buffered, format="PNG")
    control_image_b64 = base64.b64encode(buffered.getvalue()).decode()
    
    # Ensure prompt and negative_prompt are safe
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": {
            "prompt": safe_prompt,
            "image": control_image_b64,
            "negative_prompt": safe_negative_prompt
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        control_type_name = CONTROLNET_TYPES[control_type]['name']
        return image, f"API mode {control_type_name} image generation successful!"
    except Exception as e:
        return None, f"ControlNet API generation failed: {str(e)}"
```

##### 1.4 ä¿®å¤ `generate_img2img_api` å‡½æ•°
```python
def generate_img2img_api(prompt, negative_prompt, input_image, strength):
    """Generate img2img image using API"""
    endpoint = API_ENDPOINTS.get("runwayml/stable-diffusion-v1-5")
    if not endpoint:
        raise Exception("img2img API mode not supported")
    
    # Convert input image to base64
    import base64
    import io
    
    buffered = io.BytesIO()
    input_image.save(buffered, format="PNG")
    input_image_b64 = base64.b64encode(buffered.getvalue()).decode()
    
    # Ensure prompt and negative_prompt are safe
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": {
            "prompt": safe_prompt,
            "image": input_image_b64,
            "negative_prompt": safe_negative_prompt,
            "strength": strength
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        return image, "API mode img2img image generation successful!"
    except Exception as e:
        return None, f"img2img API not supported, recommend using local mode or text-to-image function: {str(e)}"
```

### 2. è´Ÿé¢è¯æ¡è¾…åŠ©åŠŸèƒ½æ·»åŠ 

#### 2.1 æ·»åŠ è´Ÿé¢è¯æ¡åˆ†ç±»
```python
# è´Ÿé¢æç¤ºè¯è¾…åŠ©è¯æ¡
NEGATIVE_PROMPT_CATEGORIES = {
    "ç”»è´¨é—®é¢˜": [
        "blurry", "low quality", "bad quality", "worst quality", "poor quality",
        "pixelated", "jpeg artifacts", "compression artifacts", "distorted",
        "low resolution", "grainy", "noisy", "oversaturated", "undersaturated"
    ],
    "è§£å‰–é”™è¯¯": [
        "bad anatomy", "bad hands", "bad fingers", "extra fingers", "missing fingers",
        "extra limbs", "missing limbs", "deformed", "mutated", "disfigured",
        "malformed", "extra arms", "extra legs", "fused fingers", "too many fingers"
    ],
    "é¢éƒ¨é—®é¢˜": [
        "bad face", "ugly face", "distorted face", "asymmetrical face",
        "bad eyes", "cross-eyed", "extra eyes", "missing eyes", "bad mouth",
        "bad teeth", "crooked teeth", "bad nose", "asymmetrical features"
    ],
    "è‰ºæœ¯é£æ ¼": [
        "cartoon", "anime", "manga", "3d render", "painting", "sketch",
        "watercolor", "oil painting", "digital art", "illustration",
        "abstract", "surreal", "unrealistic", "stylized"
    ],
    "æŠ€æœ¯é—®é¢˜": [
        "watermark", "signature", "text", "logo", "copyright", "username",
        "frame", "border", "cropped", "cut off", "out of frame",
        "duplicate", "error", "glitch", "artifact"
    ],
    "å…‰ç…§é—®é¢˜": [
        "bad lighting", "harsh lighting", "overexposed", "underexposed",
        "too dark", "too bright", "uneven lighting", "poor contrast",
        "washed out", "flat lighting", "artificial lighting"
    ],
    "æ„å›¾é—®é¢˜": [
        "bad composition", "off-center", "tilted", "crooked", "unbalanced",
        "cluttered", "messy", "chaotic", "poor framing", "bad angle",
        "awkward pose", "stiff pose", "unnatural pose"
    ]
}
```

#### 2.2 ä¿®æ”¹ç•Œé¢æ·»åŠ è´Ÿé¢è¯æ¡é€‰æ‹©å™¨
åœ¨ `create_interface()` å‡½æ•°ä¸­æ·»åŠ ï¼š

```python
# è´Ÿé¢è¯æ¡
gr.Markdown("#### ğŸš« è´Ÿé¢æç¤ºè¯ (Negative Prompt)")
with gr.Row():
    with gr.Column():
        neg_quality_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["ç”»è´¨é—®é¢˜"],
            label="ğŸš« ç”»è´¨é—®é¢˜",
            info="é¿å…ç”»è´¨ç›¸å…³é—®é¢˜"
        )
        neg_anatomy_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["è§£å‰–é”™è¯¯"],
            label="ğŸš« è§£å‰–é”™è¯¯",
            info="é¿å…èº«ä½“ç»“æ„é”™è¯¯"
        )
    with gr.Column():
        neg_face_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["é¢éƒ¨é—®é¢˜"],
            label="ğŸš« é¢éƒ¨é—®é¢˜",
            info="é¿å…é¢éƒ¨ç›¸å…³é—®é¢˜"
        )
        neg_style_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["è‰ºæœ¯é£æ ¼"],
            label="ğŸš« é¿å…é£æ ¼",
            info="æ’é™¤ä¸æƒ³è¦çš„è‰ºæœ¯é£æ ¼"
        )
    with gr.Column():
        neg_tech_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["æŠ€æœ¯é—®é¢˜"],
            label="ğŸš« æŠ€æœ¯é—®é¢˜",
            info="é¿å…æ°´å°ã€è£å‰ªç­‰æŠ€æœ¯é—®é¢˜"
        )
        neg_lighting_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["å…‰ç…§é—®é¢˜"],
            label="ğŸš« å…‰ç…§é—®é¢˜",
            info="é¿å…å…‰ç…§ç›¸å…³é—®é¢˜"
        )
    with gr.Column():
        neg_composition_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["æ„å›¾é—®é¢˜"],
            label="ğŸš« æ„å›¾é—®é¢˜",
            info="é¿å…æ„å›¾ç›¸å…³é—®é¢˜"
        )
```

#### 2.3 ä¿®æ”¹æ¯ä¸ªæ ‡ç­¾é¡µçš„æŒ‰é’®å¸ƒå±€
å°†åŸæ¥çš„å•ä¸€"åº”ç”¨æ ‡ç­¾"æŒ‰é’®æ›¿æ¢ä¸ºä¸¤ä¸ªæŒ‰é’®ï¼š

**æ–‡ç”Ÿå›¾æ¨¡å¼ï¼š**
```python
with gr.Row():
    prompt1 = gr.Textbox(
        label="æç¤ºè¯ (Prompt)",
        placeholder="æè¿°ä½ æƒ³è¦çš„å›¾åƒï¼Œä¾‹å¦‚ï¼ša beautiful landscape with mountains and lakes, highly detailed, 4k",
        lines=3,
        scale=4
    )
    with gr.Column(scale=1):
        apply_positive_to_prompt1 = gr.Button("â• æ­£é¢è¯æ¡", variant="secondary", size="sm")
        apply_negative_to_prompt1 = gr.Button("â– è´Ÿé¢è¯æ¡", variant="secondary", size="sm")
```

**ä¼ ç»Ÿå›¾ç”Ÿå›¾æ¨¡å¼ï¼š**
```python
with gr.Row():
    prompt_img2img = gr.Textbox(
        label="æç¤ºè¯ (Prompt)",
        placeholder="æè¿°æƒ³è¦çš„é£æ ¼å˜åŒ–ï¼Œä¾‹å¦‚ï¼šoil painting style, vibrant colors",
        lines=3,
        scale=4
    )
    with gr.Column(scale=1):
        apply_positive_to_img2img = gr.Button("â• æ­£é¢è¯æ¡", variant="secondary", size="sm")
        apply_negative_to_img2img = gr.Button("â– è´Ÿé¢è¯æ¡", variant="secondary", size="sm")
```

**ControlNetæ¨¡å¼ï¼š**
```python
with gr.Row():
    prompt2 = gr.Textbox(
        label="æç¤ºè¯ (Prompt)",
        placeholder="åŸºäºä¸Šä¼ å›¾åƒçš„ç»“æ„ï¼Œæè¿°æƒ³è¦çš„é£æ ¼ï¼Œä¾‹å¦‚ï¼šoil painting style, sunset colors",
        lines=3,
        scale=4
    )
    with gr.Column(scale=1):
        apply_positive_to_prompt2 = gr.Button("â• æ­£é¢è¯æ¡", variant="secondary", size="sm")
        apply_negative_to_prompt2 = gr.Button("â– è´Ÿé¢è¯æ¡", variant="secondary", size="sm")
```

#### 2.4 æ›´æ–°äº‹ä»¶ç»‘å®šé€»è¾‘
ä¿®æ”¹äº†æ ‡ç­¾åº”ç”¨é€»è¾‘ï¼Œä»ç´¯åŠ æ”¹ä¸ºæ›¿æ¢ï¼š

```python
# Prompt è¾…åŠ©å™¨äº‹ä»¶
def get_selected_positive_tags(*tag_groups):
    """è·å–æ‰€æœ‰é€‰ä¸­çš„æ­£é¢æ ‡ç­¾"""
    selected_tags = []
    for tags in tag_groups:
        if tags:
            selected_tags.extend(tags)
    return ", ".join(selected_tags) if selected_tags else ""

def get_selected_negative_tags(*tag_groups):
    """è·å–æ‰€æœ‰é€‰ä¸­çš„è´Ÿé¢æ ‡ç­¾"""
    selected_tags = []
    for tags in tag_groups:
        if tags:
            selected_tags.extend(tags)
    return ", ".join(selected_tags) if selected_tags else ""

def clear_all_tags():
    return [[] for _ in range(14)]  # 7ä¸ªæ­£é¢tagç»„ + 7ä¸ªè´Ÿé¢tagç»„

# æ­£é¢è¯æ¡åº”ç”¨åˆ°å„ä¸ªpromptæ¡†çš„äº‹ä»¶
apply_positive_to_prompt1.click(
    get_selected_positive_tags,
    inputs=[quality_tags, style_tags, lighting_tags, composition_tags, mood_tags, scene_tags, color_tags],
    outputs=[prompt1]
)

# è´Ÿé¢è¯æ¡åº”ç”¨åˆ°å„ä¸ªnegative promptæ¡†çš„äº‹ä»¶
apply_negative_to_prompt1.click(
    get_selected_negative_tags,
    inputs=[neg_quality_tags, neg_anatomy_tags, neg_face_tags, neg_style_tags, neg_tech_tags, neg_lighting_tags, neg_composition_tags],
    outputs=[negative_prompt1]
)

# ... å…¶ä»–ç±»ä¼¼çš„äº‹ä»¶ç»‘å®š
```

### 3. ç•Œé¢ä¼˜åŒ–

#### 3.1 æ›´æ–°å¸®åŠ©æ–‡æ¡£
åœ¨ç•Œé¢è¯´æ˜ä¸­æ·»åŠ äº†å…³äºè´Ÿé¢è¯æ¡çš„ä½¿ç”¨è¯´æ˜ï¼š

```markdown
### ğŸ¯ **Prompt è¾…åŠ©å™¨ä½¿ç”¨è¯´æ˜ï¼š**
- **âœ¨ æ­£é¢è¯æ¡**ï¼šæè¿°ä½ æƒ³è¦çš„æ•ˆæœã€é£æ ¼ã€è´¨é‡ç­‰
- **ğŸš« è´Ÿé¢è¯æ¡**ï¼šæè¿°ä½ ä¸æƒ³è¦çš„é—®é¢˜ã€é£æ ¼ã€ç‘•ç–µç­‰
- **ğŸ“ åº”ç”¨æ–¹å¼**ï¼šç‚¹å‡» "â•æ­£é¢è¯æ¡" æˆ– "â–è´Ÿé¢è¯æ¡" æŒ‰é’®ç›´æ¥æ›¿æ¢å½“å‰å†…å®¹
- **ğŸ’¡ ä½¿ç”¨æŠ€å·§**ï¼šå…ˆé€‰æ‹©è¯æ¡ï¼Œå†ç‚¹å‡»åº”ç”¨åˆ°å¯¹åº”çš„æç¤ºè¯æ¡†ä¸­
```

#### 3.2 æ¸…ç†é‡å¤ä»£ç 
å‘ç°å¹¶æ¸…ç†äº†ä»£ç ä¸­çš„é‡å¤å‡½æ•°å®šä¹‰ï¼Œç¡®ä¿ä»£ç ç»“æ„æ¸…æ™°ã€‚

### 4. æ–‡ä»¶ç»“æ„

æœ€ç»ˆçš„ä¸»è¦æ–‡ä»¶ï¼š
- `app.py` - ä¸»åº”ç”¨æ–‡ä»¶
- `requirements.txt` - ä¾èµ–æ–‡ä»¶
- `README.md` - é¡¹ç›®è¯´æ˜
- `ä¿®æ”¹è®°å½•.md` - æœ¬ä¿®æ”¹è®°å½•æ–‡ä»¶

### 5. åŠŸèƒ½éªŒè¯

åº”ç”¨æˆåŠŸå¯åŠ¨å¹¶è¿è¡Œåœ¨ http://127.0.0.1:7860ï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½ï¼š

1. âœ… APIæ¨¡å¼å’Œæœ¬åœ°æ¨¡å¼åˆ‡æ¢
2. âœ… å¤šæ¨¡å‹é€‰æ‹©æ”¯æŒ
3. âœ… ä¸‰ç§ç”Ÿæˆæ¨¡å¼ï¼ˆæ–‡ç”Ÿå›¾ã€ä¼ ç»Ÿå›¾ç”Ÿå›¾ã€ControlNetï¼‰
4. âœ… æ­£é¢å’Œè´Ÿé¢è¯æ¡è¾…åŠ©å™¨
5. âœ… è¯æ¡æ›¿æ¢è€Œéç´¯åŠ çš„é€»è¾‘
6. âœ… ASCIIå®‰å…¨çš„APIé”™è¯¯å¤„ç†
7. âœ… UTF-8ç¼–ç å®‰å…¨çš„promptå¤„ç†

### 6. å¾…è§£å†³é—®é¢˜

1. APIæ¨¡å¼ä¸‹çš„è¿›ä¸€æ­¥æµ‹è¯•ï¼Œç¡®ä¿ç¼–ç é—®é¢˜å®Œå…¨è§£å†³
2. å¯èƒ½éœ€è¦æ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µè°ƒæ•´API payloadæ ¼å¼
3. ControlNetå’Œimg2imgçš„APIæ¨¡å¼æ”¯æŒå¯èƒ½éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–

### 7. æŠ€æœ¯è¦ç‚¹

#### ç¼–ç å®‰å…¨å¤„ç†ç­–ç•¥ï¼š
1. æ‰€æœ‰APIç›¸å…³çš„é”™è¯¯æ¶ˆæ¯ä½¿ç”¨è‹±æ–‡
2. æ‰€æœ‰ä¼ é€’ç»™APIçš„promptå’Œnegative_promptè¿›è¡ŒUTF-8ç¼–ç è¿‡æ»¤
3. APIå“åº”çš„é”™è¯¯ä¿¡æ¯è¿›è¡ŒASCIIå®‰å…¨å¤„ç†
4. å¼‚å¸¸æ•è·æ—¶ç¡®ä¿é”™è¯¯æ¶ˆæ¯å¯ä»¥å®‰å…¨ç¼–ç 

#### ç•Œé¢è®¾è®¡æ”¹è¿›ï¼š
1. åˆ†ç¦»æ­£é¢å’Œè´Ÿé¢è¯æ¡é€‰æ‹©
2. æ¯ä¸ªç”Ÿæˆæ¨¡å¼éƒ½æœ‰ç‹¬ç«‹çš„è¯æ¡åº”ç”¨æŒ‰é’®
3. è¯æ¡åº”ç”¨é‡‡ç”¨æ›¿æ¢è€Œéç´¯åŠ é€»è¾‘
4. ä¿æŒç•Œé¢çš„ä¸€è‡´æ€§å’Œæ˜“ç”¨æ€§

---

## ä¿®æ”¹æ—¶é—´çº¿

1. **ç¼–ç é—®é¢˜è¯Šæ–­** - è¯†åˆ«åˆ°é—®é¢˜ä¸åœ¨æ³¨é‡Šè€Œåœ¨APIè°ƒç”¨è¿‡ç¨‹
2. **APIå‡½æ•°é‡æ„** - é‡å†™æ‰€æœ‰APIç›¸å…³å‡½æ•°ï¼Œç¡®ä¿ç¼–ç å®‰å…¨
3. **è´Ÿé¢è¯æ¡åŠŸèƒ½æ·»åŠ ** - æ·»åŠ 7ä¸ªåˆ†ç±»çš„è´Ÿé¢è¯æ¡
4. **ç•Œé¢å¸ƒå±€è°ƒæ•´** - ä¸ºæ¯ä¸ªç”Ÿæˆæ¨¡å¼æ·»åŠ ç‹¬ç«‹çš„è¯æ¡åº”ç”¨æŒ‰é’®
5. **äº‹ä»¶ç»‘å®šæ›´æ–°** - ä¿®æ”¹è¯æ¡åº”ç”¨é€»è¾‘ä¸ºæ›¿æ¢è€Œéç´¯åŠ 
6. **ä»£ç æ¸…ç†** - ç§»é™¤é‡å¤ä»£ç ï¼Œä¼˜åŒ–ç»“æ„
7. **åŠŸèƒ½éªŒè¯** - å¯åŠ¨åº”ç”¨ç¡®è®¤æ‰€æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ

## æœ€ç»ˆçŠ¶æ€

åº”ç”¨ç°åœ¨æ”¯æŒå®Œæ•´çš„åŒæ¨¡å¼è¿è¡Œï¼ˆAPI/æœ¬åœ°ï¼‰ï¼Œå…·å¤‡ä¸°å¯Œçš„promptè¾…åŠ©åŠŸèƒ½ï¼Œå¹¶è§£å†³äº†APIæ¨¡å¼ä¸‹çš„ç¼–ç é—®é¢˜ã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡ç•Œé¢è½»æ¾é€‰æ‹©æ­£é¢å’Œè´Ÿé¢è¯æ¡ï¼Œä¸€é”®åº”ç”¨åˆ°å¯¹åº”çš„æç¤ºè¯æ¡†ä¸­ï¼Œå¤§å¤§æå‡äº†ä½¿ç”¨ä½“éªŒã€‚
