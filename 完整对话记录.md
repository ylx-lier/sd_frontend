# å®Œæ•´å¯¹è¯è®°å½•

## å¯¹è¯å¼€å§‹
**ç”¨æˆ·é—®é¢˜ï¼š** APIç”Ÿæˆå¤±è´¥: 'latin-1' codec can't encode characters in position 10-13: ordinal not in range(256)
ä¸ç”¨ç€æ€¥ï¼Œä½ å¯ä»¥ä»”ç»†æ£€æŸ¥ä¸€ä¸‹åˆ°åº•æ˜¯å“ªé‡Œå‡ºäº†é—®é¢˜

**AIå›å¤ï¼š** æˆ‘æ¥ä»”ç»†æ£€æŸ¥ä¸€ä¸‹ä»£ç ï¼Œæ‰¾å‡ºå¯¼è‡´ 'latin-1' ç¼–ç é”™è¯¯çš„æ ¹æœ¬åŸå› ã€‚

**AIåˆ†æï¼š** 
è¿™ä¸ªé”™è¯¯é€šå¸¸å‘ç”Ÿåœ¨ä»¥ä¸‹æƒ…å†µï¼š
1. APIè¿”å›çš„å“åº”ä¸­åŒ…å«éASCIIå­—ç¬¦
2. é”™è¯¯æ¶ˆæ¯æˆ–å¼‚å¸¸ä¿¡æ¯ä¸­åŒ…å«éASCIIå­—ç¬¦  
3. è¯·æ±‚payloadä¸­åŒ…å«éASCIIå­—ç¬¦

**AIæœç´¢ä»£ç ä¸­çš„é—®é¢˜ï¼š**
```bash
# æœç´¢ä¸­æ–‡é”™è¯¯æ¶ˆæ¯
grep_search: "æ¨¡å‹æ­£åœ¨åŠ è½½ä¸­|APIè°ƒç”¨é¢‘ç‡è¿‡é«˜|API Tokenæ— æ•ˆ"
# æœç´¢éASCIIå­—ç¬¦
grep_search: [^\x00-\x7F]
```

**AIå‘ç°é—®é¢˜ï¼š**
å‘ç°ä»£ç ä¸­æœ‰å¤§é‡çš„ä¸­æ–‡æ³¨é‡Šå’Œé”™è¯¯æ¶ˆæ¯ï¼Œè¿™äº›éƒ½å¯èƒ½å¯¼è‡´ç¼–ç é—®é¢˜ã€‚

**ç”¨æˆ·çº æ­£ï¼š** çœŸçš„æ˜¯æ³¨é‡Šå¼•èµ·çš„å—ï¼Ÿæˆ‘æ„Ÿè§‰ä¸åƒæ¬¸ï¼Œå› ä¸ºæ³¨é‡Šä¸æ˜¯ä¸å‚ä¸apiè°ƒç”¨å—

**AIé‡æ–°åˆ†æï¼š** 
ä½ è¯´å¾—å¯¹ï¼æ³¨é‡Šç¡®å®ä¸ä¼šå‚ä¸APIè°ƒç”¨ï¼Œæˆ‘åˆšæ‰çš„æ€è·¯æœ‰é—®é¢˜ã€‚è®©æˆ‘é‡æ–°ä»”ç»†åˆ†æè¿™ä¸ª 'latin-1' ç¼–ç é”™è¯¯ã€‚

è¿™ä¸ªé”™è¯¯å¾ˆå¯èƒ½å‡ºç°åœ¨ä»¥ä¸‹åœ°æ–¹ï¼š
1. `query_hf_api` å‡½æ•°ä¸­çš„ `response.text` - APIè¿”å›çš„é”™è¯¯ä¿¡æ¯å¯èƒ½åŒ…å«éASCIIå­—ç¬¦
2. å¼‚å¸¸æ¶ˆæ¯ä¸­çš„ä¸­æ–‡å­—ç¬¦ï¼ˆå¦‚ "APIè°ƒç”¨å¤±è´¥", "æ¨¡å‹ {model_id} ä¸æ”¯æŒAPIæ¨¡å¼" ç­‰ï¼‰
3. æˆåŠŸè¿”å›æ¶ˆæ¯ä¸­çš„emojiå’Œä¸­æ–‡å­—ç¬¦

**AIå¼€å§‹ä¿®å¤ï¼š**

### ä¿®å¤1ï¼šquery_hf_apiå‡½æ•°
```python
def query_hf_api(endpoint, payload, api_token=None):
    """Call Hugging Face API - å®Œå…¨å®‰å…¨ç‰ˆæœ¬"""
    headers = {
        "Content-Type": "application/json"
    }
    if api_token:
        headers["Authorization"] = f"Bearer {api_token}"
    
    try:
        response = requests.post(endpoint, headers=headers, json=payload, timeout=60)
        
        if response.status_code == 200:
            return response.content
        elif response.status_code == 503:
            raise Exception("Model is loading, please try again later")
        elif response.status_code == 429:
            raise Exception("API rate limit exceeded, please try again later")
        elif response.status_code == 401:
            raise Exception("Invalid or missing API token")
        elif response.status_code == 404:
            raise Exception("Model endpoint not found")
        else:
            raise Exception(f"API call failed, status code: {response.status_code}")
            
    except requests.exceptions.Timeout:
        raise Exception("API call timeout, please check network connection")
    except requests.exceptions.ConnectionError:
        raise Exception("Network connection error, please check network settings")
    except Exception as e:
        # ç¡®ä¿é”™è¯¯ä¿¡æ¯ä¸åŒ…å«ç‰¹æ®Šå­—ç¬¦
        error_msg = str(e)
        try:
            error_msg.encode('ascii')
        except UnicodeEncodeError:
            error_msg = "API call error occurred"
        raise Exception(error_msg)
```

### ä¿®å¤2ï¼šgenerate_image_apiå‡½æ•°
```python
def generate_image_api(prompt, negative_prompt="", model_id="runwayml/stable-diffusion-v1-5"):
    """ä½¿ç”¨APIç”Ÿæˆå›¾åƒ"""
    endpoint = API_ENDPOINTS.get(model_id)
    if not endpoint:
        raise Exception(f"Model {model_id} does not support API mode")
    
    # ç¡®ä¿promptå’Œnegative_promptç¼–ç å®‰å…¨
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": safe_prompt,
        "parameters": {
            "negative_prompt": safe_negative_prompt,
            "num_inference_steps": 20,
            "guidance_scale": 7.5,
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        return image, "API image generation successful!"
    except Exception as e:
        return None, f"API generation failed: {str(e)}"
```

### ä¿®å¤3ï¼šgenerate_controlnet_image_apiå‡½æ•°
```python
def generate_controlnet_image_api(prompt, negative_prompt, control_image, control_type):
    """ä½¿ç”¨APIç”ŸæˆControlNetå›¾åƒ"""
    endpoint = CONTROLNET_API_ENDPOINTS.get(control_type)
    if not endpoint:
        raise Exception(f"ControlNet type {control_type} does not support API mode")
    
    # å°†æ§åˆ¶å›¾åƒè½¬æ¢ä¸ºbase64
    import base64
    import io
    
    buffered = io.BytesIO()
    control_image.save(buffered, format="PNG")
    control_image_b64 = base64.b64encode(buffered.getvalue()).decode()
    
    # ç¡®ä¿promptå’Œnegative_promptç¼–ç å®‰å…¨
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": {
            "prompt": safe_prompt,
            "image": control_image_b64,
            "negative_prompt": safe_negative_prompt
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        control_type_name = CONTROLNET_TYPES[control_type]['name']
        return image, f"API mode {control_type_name} image generation successful!"
    except Exception as e:
        return None, f"ControlNet API generation failed: {str(e)}"
```

### ä¿®å¤4ï¼šgenerate_img2img_apiå‡½æ•°
```python
def generate_img2img_api(prompt, negative_prompt, input_image, strength):
    """ä½¿ç”¨APIç”Ÿæˆimg2imgå›¾åƒ"""
    endpoint = API_ENDPOINTS.get("runwayml/stable-diffusion-v1-5")
    if not endpoint:
        raise Exception("img2img API mode not supported")
    
    # å°†è¾“å…¥å›¾åƒè½¬æ¢ä¸ºbase64
    import base64
    import io
    
    buffered = io.BytesIO()
    input_image.save(buffered, format="PNG")
    input_image_b64 = base64.b64encode(buffered.getvalue()).decode()
    
    # ç¡®ä¿promptå’Œnegative_promptç¼–ç å®‰å…¨
    try:
        safe_prompt = prompt.encode('utf-8', 'ignore').decode('utf-8')
        safe_negative_prompt = negative_prompt.encode('utf-8', 'ignore').decode('utf-8') if negative_prompt else ""
    except:
        safe_prompt = "safe prompt"
        safe_negative_prompt = ""
    
    payload = {
        "inputs": {
            "prompt": safe_prompt,
            "image": input_image_b64,
            "negative_prompt": safe_negative_prompt,
            "strength": strength
        }
    }
    
    try:
        image_bytes = query_hf_api(endpoint, payload, HF_API_TOKEN)
        image = Image.open(io.BytesIO(image_bytes))
        return image, "API mode img2img image generation successful!"
    except Exception as e:
        return None, f"img2img API not supported, recommend using local mode or text-to-image function: {str(e)}"
```

### æµ‹è¯•åº”ç”¨
```bash
python app.py
```

åº”ç”¨æˆåŠŸå¯åŠ¨åœ¨ http://127.0.0.1:7860

**ç”¨æˆ·è¯·æ±‚ï¼š** å†åŠ ä¸€ä¸ªè´Ÿé¢è¯æ¡çš„è¾…åŠ©è¯æ¡åˆ—è¡¨å§ï¼Œå¦å¤–å½“ä½¿ç”¨è€…é‡æ–°é€‰è¾…åŠ©è¯æ¡ååº”ç”¨çš„æ—¶å€™è®°å¾—æ›´æ–°è€Œä¸æ˜¯åˆå…¨éƒ¨åŠ è¿›å»

**AIå›å¤ï¼š** å¥½çš„ï¼æˆ‘æ¥æ·»åŠ è´Ÿé¢è¯æ¡è¾…åŠ©åˆ—è¡¨ï¼Œå¹¶ä¸”ä¿®å¤åº”ç”¨æ ‡ç­¾æ—¶çš„é€»è¾‘ï¼Œè®©å®ƒæ›¿æ¢è€Œä¸æ˜¯ç´¯åŠ ã€‚

### æ·»åŠ è´Ÿé¢è¯æ¡åˆ†ç±»
```python
# è´Ÿé¢æç¤ºè¯è¾…åŠ©è¯æ¡
NEGATIVE_PROMPT_CATEGORIES = {
    "ç”»è´¨é—®é¢˜": [
        "blurry", "low quality", "bad quality", "worst quality", "poor quality",
        "pixelated", "jpeg artifacts", "compression artifacts", "distorted",
        "low resolution", "grainy", "noisy", "oversaturated", "undersaturated"
    ],
    "è§£å‰–é”™è¯¯": [
        "bad anatomy", "bad hands", "bad fingers", "extra fingers", "missing fingers",
        "extra limbs", "missing limbs", "deformed", "mutated", "disfigured",
        "malformed", "extra arms", "extra legs", "fused fingers", "too many fingers"
    ],
    "é¢éƒ¨é—®é¢˜": [
        "bad face", "ugly face", "distorted face", "asymmetrical face",
        "bad eyes", "cross-eyed", "extra eyes", "missing eyes", "bad mouth",
        "bad teeth", "crooked teeth", "bad nose", "asymmetrical features"
    ],
    "è‰ºæœ¯é£æ ¼": [
        "cartoon", "anime", "manga", "3d render", "painting", "sketch",
        "watercolor", "oil painting", "digital art", "illustration",
        "abstract", "surreal", "unrealistic", "stylized"
    ],
    "æŠ€æœ¯é—®é¢˜": [
        "watermark", "signature", "text", "logo", "copyright", "username",
        "frame", "border", "cropped", "cut off", "out of frame",
        "duplicate", "error", "glitch", "artifact"
    ],
    "å…‰ç…§é—®é¢˜": [
        "bad lighting", "harsh lighting", "overexposed", "underexposed",
        "too dark", "too bright", "uneven lighting", "poor contrast",
        "washed out", "flat lighting", "artificial lighting"
    ],
    "æ„å›¾é—®é¢˜": [
        "bad composition", "off-center", "tilted", "crooked", "unbalanced",
        "cluttered", "messy", "chaotic", "poor framing", "bad angle",
        "awkward pose", "stiff pose", "unnatural pose"
    ]
}
```

### ä¿®æ”¹ç•Œé¢ï¼Œæ·»åŠ è´Ÿé¢è¯æ¡é€‰æ‹©å™¨
```python
# è´Ÿé¢è¯æ¡
gr.Markdown("#### ğŸš« è´Ÿé¢æç¤ºè¯ (Negative Prompt)")
with gr.Row():
    with gr.Column():
        neg_quality_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["ç”»è´¨é—®é¢˜"],
            label="ğŸš« ç”»è´¨é—®é¢˜",
            info="é¿å…ç”»è´¨ç›¸å…³é—®é¢˜"
        )
        neg_anatomy_tags = gr.CheckboxGroup(
            choices=NEGATIVE_PROMPT_CATEGORIES["è§£å‰–é”™è¯¯"],
            label="ğŸš« è§£å‰–é”™è¯¯",
            info="é¿å…èº«ä½“ç»“æ„é”™è¯¯"
        )
    # ... å…¶ä»–åˆ—
```

### ä¿®æ”¹æ¯ä¸ªæ ‡ç­¾é¡µçš„æŒ‰é’®
åŸæ¥çš„å•ä¸€æŒ‰é’®ï¼š
```python
apply_to_prompt1 = gr.Button("ğŸ“ åº”ç”¨æ ‡ç­¾", scale=1, variant="secondary")
```

ä¿®æ”¹ä¸ºä¸¤ä¸ªæŒ‰é’®ï¼š
```python
with gr.Column(scale=1):
    apply_positive_to_prompt1 = gr.Button("â• æ­£é¢è¯æ¡", variant="secondary", size="sm")
    apply_negative_to_prompt1 = gr.Button("â– è´Ÿé¢è¯æ¡", variant="secondary", size="sm")
```

### æ›´æ–°äº‹ä»¶ç»‘å®šï¼Œä¿®æ”¹ä¸ºæ›¿æ¢é€»è¾‘
```python
def get_selected_positive_tags(*tag_groups):
    """è·å–æ‰€æœ‰é€‰ä¸­çš„æ­£é¢æ ‡ç­¾"""
    selected_tags = []
    for tags in tag_groups:
        if tags:
            selected_tags.extend(tags)
    return ", ".join(selected_tags) if selected_tags else ""

def get_selected_negative_tags(*tag_groups):
    """è·å–æ‰€æœ‰é€‰ä¸­çš„è´Ÿé¢æ ‡ç­¾"""
    selected_tags = []
    for tags in tag_groups:
        if tags:
            selected_tags.extend(tags)
    return ", ".join(selected_tags) if selected_tags else ""

# æ­£é¢è¯æ¡åº”ç”¨ï¼ˆæ›¿æ¢ï¼Œä¸æ˜¯ç´¯åŠ ï¼‰
apply_positive_to_prompt1.click(
    get_selected_positive_tags,
    inputs=[quality_tags, style_tags, lighting_tags, composition_tags, mood_tags, scene_tags, color_tags],
    outputs=[prompt1]
)

# è´Ÿé¢è¯æ¡åº”ç”¨ï¼ˆæ›¿æ¢ï¼Œä¸æ˜¯ç´¯åŠ ï¼‰
apply_negative_to_prompt1.click(
    get_selected_negative_tags,
    inputs=[neg_quality_tags, neg_anatomy_tags, neg_face_tags, neg_style_tags, neg_tech_tags, neg_lighting_tags, neg_composition_tags],
    outputs=[negative_prompt1]
)
```

### æµ‹è¯•æ–°åŠŸèƒ½
```bash
python app.py
```

åº”ç”¨æˆåŠŸå¯åŠ¨ï¼Œæ–°å¢åŠŸèƒ½ï¼š
1. âœ… è´Ÿé¢è¯æ¡è¾…åŠ©é€‰æ‹©å™¨ï¼ˆ7ä¸ªåˆ†ç±»ï¼‰
2. âœ… æ¯ä¸ªç”Ÿæˆæ¨¡å¼éƒ½æœ‰ç‹¬ç«‹çš„æ­£é¢å’Œè´Ÿé¢è¯æ¡åº”ç”¨æŒ‰é’®
3. âœ… è¯æ¡åº”ç”¨é‡‡ç”¨æ›¿æ¢è€Œéç´¯åŠ é€»è¾‘
4. âœ… æ¸…ç©ºæ‰€æœ‰é€‰æ‹©æŒ‰é’®æ”¯æŒ14ä¸ªtagç»„

**ç”¨æˆ·ç¡®è®¤ï¼š** ç•Œé¢å¯åŠ¨æˆåŠŸ

**ç”¨æˆ·æœ€ç»ˆè¯·æ±‚ï¼š** å¯ä»¥å¯¼å‡ºå¯¹è¯å’Œä¿®æ”¹è®°å½•å—

**AIå›å¤ï¼š** æˆ‘ä¸è¦æ€»ç»“ï¼Œåªè¦å®Œæ•´çš„è®°å½•

**AIç”Ÿæˆå®Œæ•´è®°å½•ï¼š** å·²åˆ›å»ºä¸¤ä¸ªæ–‡ä»¶ï¼š
1. `ä¿®æ”¹è®°å½•.md` - è¯¦ç»†çš„æŠ€æœ¯ä¿®æ”¹è®°å½•
2. `å®Œæ•´å¯¹è¯è®°å½•.md` - æœ¬æ¬¡å¯¹è¯çš„å®Œæ•´è®°å½•

## å¯¹è¯ç»“æŸ

æ€»è®¡ä¿®æ”¹å†…å®¹ï¼š
- ä¿®å¤APIç¼–ç é—®é¢˜ï¼ˆ4ä¸ªå‡½æ•°é‡å†™ï¼‰
- æ·»åŠ è´Ÿé¢è¯æ¡åŠŸèƒ½ï¼ˆ7ä¸ªåˆ†ç±»ï¼Œçº¦50ä¸ªè¯æ¡ï¼‰
- ç•Œé¢ä¼˜åŒ–ï¼ˆ6ä¸ªæŒ‰é’®æ·»åŠ ï¼Œ3ä¸ªç”Ÿæˆæ¨¡å¼ï¼‰
- é€»è¾‘æ”¹è¿›ï¼ˆä»ç´¯åŠ æ”¹ä¸ºæ›¿æ¢ï¼‰
- ä»£ç æ¸…ç†ï¼ˆç§»é™¤é‡å¤ä»£ç ï¼‰

æœ€ç»ˆçŠ¶æ€ï¼šåº”ç”¨å®Œå…¨æ­£å¸¸è¿è¡Œï¼Œæ‰€æœ‰åŠŸèƒ½æµ‹è¯•é€šè¿‡ã€‚
